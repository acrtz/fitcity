"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAlias = exports.simplify = exports.parse = undefined;
exports.getAliasFromResolveInfo = getAliasFromResolveInfo;
exports.parseResolveInfo = parseResolveInfo;
exports.simplifyParsedResolveInfoFragmentWithType = simplifyParsedResolveInfoFragmentWithType;

var _assert = require("assert");

var _assert2 = _interopRequireDefault(_assert);

var _values = require("graphql/execution/values");

var _graphql = require("graphql");

var _debug = require("debug");

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("graphql-parse-resolve-info");

function getArgVal(resolveInfo, argument) {
  if (argument.kind === "Variable") {
    return resolveInfo.variableValues[argument.name.value];
  } else if (argument.kind === "BooleanValue") {
    return argument.value;
  }
}

function skipField(resolveInfo, { directives = [] }) {
  let skip = false;
  directives.forEach(directive => {
    const directiveName = directive.name.value;
    if (Array.isArray(directive.arguments)) {
      const ifArgumentAst = directive.arguments.find(arg => arg.name && arg.name.value === "if");
      if (ifArgumentAst) {
        const argumentValueAst = ifArgumentAst.value;
        if (directiveName === "skip") {
          skip = skip || getArgVal(resolveInfo, argumentValueAst);
        } else if (directiveName === "include") {
          skip = skip || !getArgVal(resolveInfo, argumentValueAst);
        }
      }
    }
  });
  return skip;
}

// Originally based on https://github.com/tjmehta/graphql-parse-fields

function getAliasFromResolveInfo(resolveInfo) {
  const asts = resolveInfo.fieldNodes || resolveInfo.fieldASTs;
  for (let i = 0, l = asts.length; i < l; i++) {
    const val = asts[i];
    if (val.kind === "Field") {
      const alias = val.alias ? val.alias.value : val.name && val.name.value;
      if (alias) {
        return alias;
      }
    }
  }
  throw new Error("Could not determine alias?!");
}

function parseResolveInfo(resolveInfo, options = {}) {
  const fieldNodes = resolveInfo.fieldNodes || resolveInfo.fieldASTs;

  const { parentType } = resolveInfo;
  if (!fieldNodes) {
    throw new Error("No fieldNodes provided!");
  }
  if (options.keepRoot == null) {
    options.keepRoot = false;
  }
  if (options.deep == null) {
    options.deep = true;
  }
  let tree = fieldTreeFromAST(fieldNodes, resolveInfo, undefined, options, parentType);
  if (!options.keepRoot) {
    const typeKey = firstKey(tree);
    if (!typeKey) {
      return null;
    }
    tree = tree[typeKey];
    const fieldKey = firstKey(tree);
    if (!fieldKey) {
      return null;
    }
    tree = tree[fieldKey];
  }
  return tree;
}

function getFieldFromAST(ast, parentType) {
  if (ast.kind === "Field") {
    const fieldNode = ast;
    const fieldName = fieldNode.name.value;
    if (!(parentType instanceof _graphql.GraphQLUnionType)) {
      const type = parentType;
      return type.getFields()[fieldName];
    } else {
      // XXX: TODO: Handle GraphQLUnionType
    }
  }
  return;
}

let iNum = 1;
function fieldTreeFromAST(inASTs, resolveInfo, initTree = {}, options = {}, parentType, depth = "") {
  const instance = iNum++;
  debug("%s[%d] Entering fieldTreeFromAST with parent type '%s'", depth, instance, parentType);
  let { variableValues } = resolveInfo;
  const fragments = resolveInfo.fragments || {};
  const asts = Array.isArray(inASTs) ? inASTs : [inASTs];
  initTree[parentType.name] = initTree[parentType.name] || {};
  const outerDepth = depth;
  return asts.reduce(function (tree, selectionVal, idx) {
    const depth = `${outerDepth}  `;
    debug("%s[%d] Processing AST %d of %d; kind = %s", depth, instance, idx + 1, asts.length, selectionVal.kind);
    if (skipField(resolveInfo, selectionVal)) {
      debug("%s[%d] IGNORING due to directive", depth, instance);
    } else if (selectionVal.kind === "Field") {
      const val = selectionVal;
      const name = val.name && val.name.value;
      const isReserved = name && name !== "__id" && name.substr(0, 2) === "__";
      if (isReserved) {
        debug("%s[%d] IGNORING because field '%s' is reserved", depth, instance, name);
      } else {
        const alias = val.alias && val.alias.value ? val.alias.value : val.name.value;
        debug("%s[%d] Field '%s' (alias = '%s')", depth, instance, name, alias);
        const field = getFieldFromAST(val, parentType);
        if (!field) {
          return tree;
        }
        const fieldGqlType = (0, _graphql.getNamedType)(field.type);
        if (!fieldGqlType) {
          return tree;
        }
        const args = (0, _values.getArgumentValues)(field, val, variableValues) || {};
        if (parentType.name && !tree[parentType.name][alias]) {
          const newTreeRoot = {
            name,
            alias,
            args,
            fieldsByTypeName: (0, _graphql.isCompositeType)(fieldGqlType) ? {
              [fieldGqlType.name]: {}
            } : {}
          };
          tree[parentType.name][alias] = newTreeRoot;
        }
        const selectionSet = val.selectionSet;
        if (selectionSet != null && options.deep && (0, _graphql.isCompositeType)(fieldGqlType)) {
          const newParentType = fieldGqlType;
          debug("%s[%d] Recursing into subfields", depth, instance);
          fieldTreeFromAST(selectionSet.selections, resolveInfo, tree[parentType.name][alias].fieldsByTypeName, options, newParentType, `${depth}  `);
        } else {
          // No fields to add
          debug("%s[%d] Exiting (no fields to add)", depth, instance);
        }
      }
    } else if (selectionVal.kind === "FragmentSpread" && options.deep) {
      const val = selectionVal;
      const name = val.name && val.name.value;
      debug("%s[%d] Fragment spread '%s'", depth, instance, name);
      const fragment = fragments[name];
      (0, _assert2.default)(fragment, 'unknown fragment "' + name + '"');
      let fragmentType = parentType;
      if (fragment.typeCondition) {
        fragmentType = getType(resolveInfo, fragment.typeCondition);
      }
      if (fragmentType && (0, _graphql.isCompositeType)(fragmentType)) {
        const newParentType = fragmentType;
        fieldTreeFromAST(fragment.selectionSet.selections, resolveInfo, tree, options, newParentType, `${depth}  `);
      }
    } else if (selectionVal.kind === "InlineFragment" && options.deep) {
      const val = selectionVal;
      const fragment = val;
      let fragmentType = parentType;
      if (fragment.typeCondition) {
        fragmentType = getType(resolveInfo, fragment.typeCondition);
      }
      debug("%s[%d] Inline fragment (parent = '%s', type = '%s')", depth, instance, parentType, fragmentType);
      if (fragmentType && (0, _graphql.isCompositeType)(fragmentType)) {
        const newParentType = fragmentType;
        fieldTreeFromAST(fragment.selectionSet.selections, resolveInfo, tree, options, newParentType, `${depth}  `);
      }
    } else {
      debug("%s[%d] IGNORING because kind '%s' not understood", depth, instance, selectionVal.kind);
    }
    // Ref: https://github.com/graphile/postgraphile/pull/342/files#diff-d6702ec9fed755c88b9d70b430fda4d8R148
    return tree;
  }, initTree);
}

function firstKey(obj) {
  for (const key in obj) {
    return key;
  }
}

function getType(resolveInfo, typeCondition) {
  const { schema } = resolveInfo;
  const { kind, name } = typeCondition;
  if (kind === "NamedType") {
    const typeName = name.value;
    return schema.getType(typeName);
  }
}

function simplifyParsedResolveInfoFragmentWithType(parsedResolveInfoFragment, Type) {
  const { fieldsByTypeName } = parsedResolveInfoFragment;
  const fields = {};
  const StrippedType = (0, _graphql.getNamedType)(Type);
  if ((0, _graphql.isCompositeType)(StrippedType)) {
    Object.assign(fields, fieldsByTypeName[StrippedType.name]);
    if (StrippedType instanceof _graphql.GraphQLObjectType) {
      const ObjectType = StrippedType;
      // GraphQL ensures that the subfields cannot clash, so it's safe to simply overwrite them
      for (const Interface of ObjectType.getInterfaces()) {
        Object.assign(fields, fieldsByTypeName[Interface.name]);
      }
    }
  }
  return Object.assign({}, parsedResolveInfoFragment, {
    fields
  });
}

const parse = exports.parse = parseResolveInfo;
const simplify = exports.simplify = simplifyParsedResolveInfoFragmentWithType;
const getAlias = exports.getAlias = getAliasFromResolveInfo;
//# sourceMappingURL=index.js.map