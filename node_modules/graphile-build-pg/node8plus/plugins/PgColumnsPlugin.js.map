{"version":3,"sources":["../../src/plugins/PgColumnsPlugin.js"],"names":["nullableIf","GraphQLNonNull","condition","Type","PgColumnsPlugin","builder","hook","fields","build","context","extend","pgGetGqlTypeByTypeId","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","pg2gql","graphql","GraphQLString","pgTweakFragmentForType","pgColumnFilter","inflection","scope","isPgRowType","isPgCompoundType","pgIntrospection","table","fieldWithHooks","Self","kind","attribute","filter","attr","classId","id","reduce","memo","fieldName","column","Error","namespaceName","name","getDataFromParsedResolveInfoFragment","addDataGenerator","ReturnType","typeId","parsedResolveInfoFragment","pgQuery","queryBuilder","getSelectValueForFieldAndType","sqlFullName","type","isPgArray","ident","identifier","Symbol","fragment","arrayItemType","resolveData","jsonBuildObject","onlyJsonField","addNullCase","select","getTableAlias","description","isNotNull","domainIsNotNull","resolve","data","_args","_context","_resolveInfo","pgFieldIntrospection","pgGetGqlInputTypeByTypeId","isPgPatch","pgAddSubfield","hasDefault"],"mappings":"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","file":"PgColumnsPlugin.js","sourcesContent":["// @flow\nimport queryFromResolveData from \"../queryFromResolveData\";\nimport type { Plugin } from \"graphile-build\";\nimport omit from \"../omit\";\n\nconst nullableIf = (GraphQLNonNull, condition, Type) =>\n  condition ? Type : new GraphQLNonNull(Type);\n\nexport default (function PgColumnsPlugin(builder) {\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      pgGetGqlTypeByTypeId,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgSql: sql,\n      pg2gql,\n      graphql: { GraphQLString, GraphQLNonNull },\n      pgTweakFragmentForType,\n      pgColumnFilter,\n      inflection,\n    } = build;\n    const {\n      scope: { isPgRowType, isPgCompoundType, pgIntrospection: table },\n      fieldWithHooks,\n      Self,\n    } = context;\n    if (\n      !(isPgRowType || isPgCompoundType) ||\n      !table ||\n      table.kind !== \"class\"\n    ) {\n      return fields;\n    }\n    return extend(\n      fields,\n      introspectionResultsByKind.attribute\n        .filter(attr => attr.classId === table.id)\n        .filter(attr => pgColumnFilter(attr, build, context))\n        .reduce((memo, attr) => {\n          if (omit(attr, \"read\")) {\n            return memo;\n          }\n          /*\n            attr =\n              { kind: 'attribute',\n                classId: '6546809',\n                num: 21,\n                name: 'upstreamName',\n                description: null,\n                typeId: '6484393',\n                isNotNull: false,\n                hasDefault: false }\n            */\n          const fieldName = inflection.column(attr);\n          if (memo[fieldName]) {\n            throw new Error(\n              `Two columns produce the same GraphQL field name '${fieldName}' on class '${\n                table.namespaceName\n              }.${table.name}'; one of them is '${attr.name}'`\n            );\n          }\n          memo[fieldName] = fieldWithHooks(\n            fieldName,\n            ({ getDataFromParsedResolveInfoFragment, addDataGenerator }) => {\n              const ReturnType =\n                pgGetGqlTypeByTypeId(attr.typeId) || GraphQLString;\n              addDataGenerator(parsedResolveInfoFragment => {\n                return {\n                  pgQuery: queryBuilder => {\n                    const getSelectValueForFieldAndType = (\n                      sqlFullName,\n                      type\n                    ) => {\n                      if (type.isPgArray) {\n                        const ident = sql.identifier(Symbol());\n                        return sql.fragment`\n                          (\n                            case\n                            when ${sqlFullName} is null then null\n                            when coalesce(array_length(${sqlFullName}, 1), 0) = 0 then '[]'::json\n                            else\n                              (\n                                select json_agg(${getSelectValueForFieldAndType(\n                                  ident,\n                                  type.arrayItemType\n                                )})\n                                from unnest(${sqlFullName}) as ${ident}\n                              )\n                            end\n                          )\n                        `;\n                      } else if (type.type === \"c\") {\n                        const resolveData = getDataFromParsedResolveInfoFragment(\n                          parsedResolveInfoFragment,\n                          ReturnType\n                        );\n                        const jsonBuildObject = queryFromResolveData(\n                          sql.identifier(Symbol()), // Ignore!\n                          sqlFullName,\n                          resolveData,\n                          { onlyJsonField: true, addNullCase: true }\n                        );\n                        return jsonBuildObject;\n                      } else {\n                        return pgTweakFragmentForType(sqlFullName, type);\n                      }\n                    };\n                    queryBuilder.select(\n                      getSelectValueForFieldAndType(\n                        sql.fragment`(${queryBuilder.getTableAlias()}.${sql.identifier(\n                          attr.name\n                        )})`, // The brackets are necessary to stop the parser getting confused, ref: https://www.postgresql.org/docs/9.6/static/rowtypes.html#ROWTYPES-ACCESSING\n                        attr.type\n                      ),\n                      fieldName\n                    );\n                  },\n                };\n              });\n              return {\n                description: attr.description,\n                type: nullableIf(\n                  GraphQLNonNull,\n                  !attr.isNotNull && !attr.type.domainIsNotNull,\n                  ReturnType\n                ),\n                resolve: (data, _args, _context, _resolveInfo) => {\n                  return pg2gql(data[fieldName], attr.type);\n                },\n              };\n            },\n            { pgFieldIntrospection: attr }\n          );\n          return memo;\n        }, {}),\n      `Adding columns to '${Self.name}'`\n    );\n  });\n  builder.hook(\"GraphQLInputObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      pgGetGqlInputTypeByTypeId,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      graphql: { GraphQLString, GraphQLNonNull },\n      pgColumnFilter,\n      inflection,\n    } = build;\n    const {\n      scope: {\n        isPgRowType,\n        isPgCompoundType,\n        isPgPatch,\n        pgIntrospection: table,\n        pgAddSubfield,\n      },\n      fieldWithHooks,\n      Self,\n    } = context;\n    if (\n      !(isPgRowType || isPgCompoundType) ||\n      !table ||\n      table.kind !== \"class\"\n    ) {\n      return fields;\n    }\n    return extend(\n      fields,\n      introspectionResultsByKind.attribute\n        .filter(attr => attr.classId === table.id)\n        .filter(attr => pgColumnFilter(attr, build, context))\n        .reduce((memo, attr) => {\n          if (omit(attr, isPgPatch ? \"update\" : \"create\")) {\n            return memo;\n          }\n          const fieldName = inflection.column(attr);\n          if (memo[fieldName]) {\n            throw new Error(\n              `Two columns produce the same GraphQL field name '${fieldName}' on input class '${\n                table.namespaceName\n              }.${table.name}'; one of them is '${attr.name}'`\n            );\n          }\n          memo[fieldName] = fieldWithHooks(\n            fieldName,\n            pgAddSubfield(fieldName, attr.name, attr.type, {\n              description: attr.description,\n              type: nullableIf(\n                GraphQLNonNull,\n                isPgPatch ||\n                  (!attr.isNotNull && !attr.type.domainIsNotNull) ||\n                  attr.hasDefault,\n                pgGetGqlInputTypeByTypeId(attr.typeId) || GraphQLString\n              ),\n            }),\n            { pgFieldIntrospection: attr }\n          );\n          return memo;\n        }, {}),\n      `Adding columns to input object '${Self.name}'`\n    );\n  });\n}: Plugin);\n"]}