{"version":3,"sources":["../../src/plugins/makeProcField.js"],"names":["makeProcField","debugSql","firstValue","obj","firstKey","k","fieldName","proc","pgIntrospectionResultsByKind","introspectionResultsByKind","pgGetGqlTypeByTypeId","pgGetGqlInputTypeByTypeId","getTypeByName","pgSql","sql","parseResolveInfo","getSafeAliasFromResolveInfo","getSafeAliasFromAlias","gql2pg","pg2gql","newWithHooks","pgStrictFunctions","strictFunctions","pgTweakFragmentForType","graphql","GraphQLNonNull","GraphQLList","GraphQLString","GraphQLInt","GraphQLFloat","GraphQLBoolean","GraphQLObjectType","GraphQLInputObjectType","getNamedType","isCompositeType","inflection","fieldWithHooks","computed","isMutation","forceList","pluralize","camelCase","getResultFieldName","gqlType","type","returnsSet","tags","resultFieldName","gqlNamedType","name","isPgArray","Error","sliceAmount","argNames","argTypeIds","slice","map","_","idx","argTypes","typeId","typeById","requiredArgCount","Math","max","length","argDefaultsNum","notNullArgCount","isStrict","argGqlTypes","Type","id","rawReturnType","returnTypeId","returnType","arrayItemType","returnTypeTable","classById","classId","fieldScope","payloadTypeScope","pgFieldIntrospection","pgIntrospection","returnFirstValueAsValue","TableType","isTableLike","isPgFieldSimpleCollection","ConnectionType","connection","isPgFieldConnection","pgFieldIntrospectionTable","pgIntrospectionTable","connectionTypeName","scalarFunctionConnection","addDataGenerator","getDataFromParsedResolveInfoFragment","addArgDataGenerator","addPgCursorPrefix","pgCursorPrefix","literal","makeMutationCall","parsedResolveInfoFragment","ReturnType","implicitArgs","args","rawArgs","input","sqlArgValues","haveNames","argIndex","argName","gqlArgName","argument","value","sqlValue","sqlArgName","identifier","unshift","fragment","functionCall","namespace","join","makeQuery","sqlMutationQuery","functionAlias","resolveData","query","withPagination","withPaginationAsFields","asJson","asJsonAggregate","addNullCase","innerQueryBuilder","select","pgQuery","queryBuilder","parentTableAlias","getTableAlias","Symbol","alias","PayloadType","reduce","memo","isNotVoid","String","functionPayloadType","description","functionMutationName","fields","recurseDataGeneratorsForField","Object","assign","clientMutationId","resolve","data","isMutationPayload","InputType","functionInputType","isMutationInput","scalarAwarePg2gql","v","_args","_context","resolveInfo","safeAlias","pgClient","queryResultRows","intermediateIdentifier","isVoid","isPgClass","namespaceName","e","text","values","compile","enabled","queryResult","rows","row","result"],"mappings":"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","file":"makeProcField.js","sourcesContent":["// @flow\nimport debugFactory from \"debug\";\nimport queryFromResolveData from \"../queryFromResolveData\";\nimport addStartEndCursor from \"./addStartEndCursor\";\nimport viaTemporaryTable from \"./viaTemporaryTable\";\n\nimport type { Build, FieldWithHooksFunction } from \"graphile-build\";\nimport type { PgProc } from \"./PgIntrospectionPlugin\";\nimport type { SQL } from \"pg-sql2\";\n\nconst debugSql = debugFactory(\"graphile-build-pg:sql\");\nconst firstValue = obj => {\n  let firstKey;\n  for (const k in obj) {\n    if (k[0] !== \"_\" && k[1] !== \"_\") {\n      firstKey = k;\n    }\n  }\n  return obj[firstKey];\n};\n\nexport default function makeProcField(\n  fieldName: string,\n  proc: PgProc,\n  {\n    pgIntrospectionResultsByKind: introspectionResultsByKind,\n    pgGetGqlTypeByTypeId,\n    pgGetGqlInputTypeByTypeId,\n    getTypeByName,\n    pgSql: sql,\n    parseResolveInfo,\n    getSafeAliasFromResolveInfo,\n    getSafeAliasFromAlias,\n    gql2pg,\n    pg2gql,\n    newWithHooks,\n    pgStrictFunctions: strictFunctions,\n    pgTweakFragmentForType,\n    graphql: {\n      GraphQLNonNull,\n      GraphQLList,\n      GraphQLString,\n      GraphQLInt,\n      GraphQLFloat,\n      GraphQLBoolean,\n      GraphQLObjectType,\n      GraphQLInputObjectType,\n      getNamedType,\n      isCompositeType,\n    },\n    inflection,\n  }: {| ...Build |},\n  {\n    fieldWithHooks,\n    computed = false,\n    isMutation = false,\n    forceList = false,\n  }: {\n    fieldWithHooks: FieldWithHooksFunction,\n    computed?: boolean,\n    isMutation?: boolean,\n    forceList?: boolean,\n  }\n) {\n  const { pluralize, camelCase } = inflection;\n  function getResultFieldName(proc, gqlType, type, returnsSet) {\n    if (proc.tags.resultFieldName) {\n      return proc.tags.resultFieldName;\n    }\n    const gqlNamedType = getNamedType(gqlType);\n    let name;\n    if (gqlNamedType === GraphQLInt) {\n      name = \"integer\";\n    } else if (gqlNamedType === GraphQLFloat) {\n      name = \"float\";\n    } else if (gqlNamedType === GraphQLBoolean) {\n      name = \"boolean\";\n    } else if (gqlNamedType === GraphQLString) {\n      name = \"string\";\n    } else {\n      name = camelCase(gqlNamedType.name);\n    }\n    return returnsSet || type.isPgArray ? pluralize(name) : name;\n  }\n  if (computed && isMutation) {\n    throw new Error(\"Mutation procedure cannot be computed\");\n  }\n  const sliceAmount = computed ? 1 : 0;\n  const argNames = proc.argTypeIds\n    .slice(sliceAmount)\n    .map((_, idx) => proc.argNames[idx + sliceAmount] || \"\");\n  const argTypes = proc.argTypeIds\n    .slice(sliceAmount)\n    .map(typeId => introspectionResultsByKind.typeById[typeId]);\n  const requiredArgCount = Math.max(0, argNames.length - proc.argDefaultsNum);\n  const notNullArgCount =\n    proc.isStrict || strictFunctions ? requiredArgCount : 0;\n  const argGqlTypes = argTypes.map((type, idx) => {\n    const Type = pgGetGqlInputTypeByTypeId(type.id) || GraphQLString;\n    if (idx >= notNullArgCount) {\n      return Type;\n    } else {\n      return new GraphQLNonNull(Type);\n    }\n  });\n\n  const rawReturnType = introspectionResultsByKind.typeById[proc.returnTypeId];\n  const returnType = rawReturnType.isPgArray\n    ? rawReturnType.arrayItemType\n    : rawReturnType;\n  const returnTypeTable =\n    introspectionResultsByKind.classById[returnType.classId];\n  if (!returnType) {\n    throw new Error(\n      `Could not determine return type for function '${proc.name}'`\n    );\n  }\n  let type;\n  const fieldScope = {};\n  const payloadTypeScope = {};\n  fieldScope.pgFieldIntrospection = proc;\n  payloadTypeScope.pgIntrospection = proc;\n  let returnFirstValueAsValue = false;\n  const TableType =\n    returnTypeTable && pgGetGqlTypeByTypeId(returnTypeTable.type.id);\n\n  const isTableLike: boolean =\n    (TableType && isCompositeType(TableType)) || false;\n  if (isTableLike) {\n    if (proc.returnsSet) {\n      if (isMutation) {\n        type = new GraphQLList(TableType);\n      } else if (forceList) {\n        type = new GraphQLList(TableType);\n        fieldScope.isPgFieldSimpleCollection = true;\n      } else {\n        const ConnectionType = getTypeByName(\n          inflection.connection(TableType.name)\n        );\n        if (!ConnectionType) {\n          throw new Error(\n            `Do not have a connection type '${inflection.connection(\n              TableType.name\n            )}' for '${TableType.name}' so cannot create procedure field`\n          );\n        }\n        type = new GraphQLNonNull(ConnectionType);\n        fieldScope.isPgFieldConnection = true;\n      }\n      fieldScope.pgFieldIntrospectionTable = returnTypeTable;\n      payloadTypeScope.pgIntrospectionTable = returnTypeTable;\n    } else {\n      type = TableType;\n      if (rawReturnType.isPgArray) {\n        type = new GraphQLList(type);\n      }\n      fieldScope.pgFieldIntrospectionTable = returnTypeTable;\n      payloadTypeScope.pgIntrospectionTable = returnTypeTable;\n    }\n  } else {\n    const Type = pgGetGqlTypeByTypeId(returnType.id) || GraphQLString;\n    if (proc.returnsSet) {\n      const connectionTypeName = inflection.scalarFunctionConnection(proc);\n      const ConnectionType = getTypeByName(connectionTypeName);\n      if (isMutation) {\n        // Cannot return a connection because it would have to run the mutation again\n        type = new GraphQLList(Type);\n        returnFirstValueAsValue = true;\n      } else if (forceList || !ConnectionType) {\n        type = new GraphQLList(Type);\n        returnFirstValueAsValue = true;\n        fieldScope.isPgFieldSimpleCollection = true;\n      } else {\n        type = new GraphQLNonNull(ConnectionType);\n        fieldScope.isPgFieldConnection = true;\n        // We don't return the first value as the value here because it gets\n        // sent down into PgScalarFunctionConnectionPlugin so the relevant\n        // EdgeType can return cursor / node; i.e. we might want to add an\n        // `__cursor` field so we can't just use a scalar.\n      }\n    } else {\n      returnFirstValueAsValue = true;\n      type = Type;\n      if (rawReturnType.isPgArray) {\n        type = new GraphQLList(type);\n      }\n    }\n  }\n  return fieldWithHooks(\n    fieldName,\n    ({\n      addDataGenerator,\n      getDataFromParsedResolveInfoFragment,\n      addArgDataGenerator,\n    }) => {\n      if (\n        proc.returnsSet &&\n        !isTableLike &&\n        !returnFirstValueAsValue &&\n        !isMutation\n      ) {\n        // Natural ordering\n        addArgDataGenerator(function addPgCursorPrefix() {\n          return {\n            pgCursorPrefix: sql.literal(\"natural\"),\n          };\n        });\n      }\n      function makeMutationCall(\n        parsedResolveInfoFragment,\n        ReturnType,\n        { implicitArgs = [] } = {}\n      ): SQL {\n        const { args: rawArgs = {} } = parsedResolveInfoFragment;\n        const args = isMutation ? rawArgs.input : rawArgs;\n        const sqlArgValues = [];\n        let haveNames = true;\n        for (let argIndex = argNames.length - 1; argIndex >= 0; argIndex--) {\n          const argName = argNames[argIndex];\n          const gqlArgName = inflection.argument(argName, argIndex);\n          const value = args[gqlArgName];\n          const sqlValue = gql2pg(value, argTypes[argIndex]);\n          if (argIndex + 1 > requiredArgCount && haveNames && value == null) {\n            // No need to pass argument to function\n            continue;\n          } else if (argIndex + 1 > requiredArgCount && haveNames) {\n            const sqlArgName = argName ? sql.identifier(argName) : null;\n            if (sqlArgName) {\n              sqlArgValues.unshift(sql.fragment`${sqlArgName} := ${sqlValue}`);\n            } else {\n              haveNames = false;\n              sqlArgValues.unshift(sqlValue);\n            }\n          } else {\n            sqlArgValues.unshift(sqlValue);\n          }\n        }\n        const functionCall = sql.fragment`${sql.identifier(\n          proc.namespace.name,\n          proc.name\n        )}(${sql.join([...implicitArgs, ...sqlArgValues], \", \")})`;\n        return rawReturnType.isPgArray\n          ? sql.fragment`unnest(${functionCall})`\n          : functionCall;\n      }\n      function makeQuery(\n        parsedResolveInfoFragment,\n        ReturnType,\n        sqlMutationQuery,\n        functionAlias\n      ) {\n        const resolveData = getDataFromParsedResolveInfoFragment(\n          parsedResolveInfoFragment,\n          ReturnType\n        );\n        const query = queryFromResolveData(\n          sqlMutationQuery,\n          functionAlias,\n          resolveData,\n          {\n            withPagination: !forceList && !isMutation && proc.returnsSet,\n            withPaginationAsFields:\n              !forceList && !isMutation && proc.returnsSet && !computed,\n            asJson:\n              computed &&\n              (forceList || (!proc.returnsSet && !returnFirstValueAsValue)),\n            asJsonAggregate:\n              computed &&\n              (forceList || (!proc.returnsSet && rawReturnType.isPgArray)),\n            addNullCase:\n              !proc.returnsSet && !rawReturnType.isPgArray && isTableLike,\n          },\n          innerQueryBuilder => {\n            if (!isTableLike) {\n              if (returnTypeTable) {\n                innerQueryBuilder.select(\n                  pgTweakFragmentForType(\n                    sql.fragment`${functionAlias}`,\n                    returnTypeTable.type\n                  ),\n                  \"value\"\n                );\n              } else {\n                innerQueryBuilder.select(\n                  pgTweakFragmentForType(\n                    sql.fragment`${functionAlias}.${functionAlias}`,\n                    returnType\n                  ),\n                  \"value\"\n                );\n              }\n            }\n          }\n        );\n        return query;\n      }\n      if (computed) {\n        addDataGenerator((parsedResolveInfoFragment, ReturnType) => {\n          return {\n            pgQuery: queryBuilder => {\n              queryBuilder.select(() => {\n                const parentTableAlias = queryBuilder.getTableAlias();\n                const functionAlias = sql.identifier(Symbol());\n                const sqlMutationQuery = makeMutationCall(\n                  parsedResolveInfoFragment,\n                  ReturnType,\n                  {\n                    implicitArgs: [parentTableAlias],\n                  }\n                );\n                const query = makeQuery(\n                  parsedResolveInfoFragment,\n                  ReturnType,\n                  sqlMutationQuery,\n                  functionAlias\n                );\n                return sql.fragment`(${query})`;\n              }, getSafeAliasFromAlias(parsedResolveInfoFragment.alias));\n            },\n          };\n        });\n      }\n\n      let ReturnType = type;\n      let PayloadType;\n      let args = argNames.reduce((memo, argName, argIndex) => {\n        const gqlArgName = inflection.argument(argName, argIndex);\n        memo[gqlArgName] = {\n          type: argGqlTypes[argIndex],\n        };\n        return memo;\n      }, {});\n      if (isMutation) {\n        const resultFieldName = getResultFieldName(\n          proc,\n          type,\n          rawReturnType,\n          proc.returnsSet\n        );\n        const isNotVoid = String(returnType.id) !== \"2278\";\n        // If set then plural name\n        PayloadType = newWithHooks(\n          GraphQLObjectType,\n          {\n            name: inflection.functionPayloadType(proc),\n            description: `The output of our \\`${inflection.functionMutationName(\n              proc\n            )}\\` mutation.`,\n            fields: ({ recurseDataGeneratorsForField }) => {\n              if (isNotVoid) {\n                recurseDataGeneratorsForField(resultFieldName);\n              }\n              return Object.assign(\n                {},\n                {\n                  clientMutationId: {\n                    type: GraphQLString,\n                  },\n                },\n                isNotVoid\n                  ? {\n                      [resultFieldName]: {\n                        type: type,\n                        resolve(data) {\n                          return data.data;\n                        },\n                      },\n                      // Result\n                    }\n                  : null\n              );\n            },\n          },\n          Object.assign(\n            {},\n            {\n              isMutationPayload: true,\n            },\n            payloadTypeScope\n          )\n        );\n        ReturnType = PayloadType;\n        const InputType = newWithHooks(\n          GraphQLInputObjectType,\n          {\n            name: inflection.functionInputType(proc),\n            description: `All input for the \\`${inflection.functionMutationName(\n              proc\n            )}\\` mutation.`,\n            fields: Object.assign(\n              {\n                clientMutationId: {\n                  type: GraphQLString,\n                },\n              },\n              args\n            ),\n          },\n          {\n            isMutationInput: true,\n          }\n        );\n        args = {\n          input: {\n            type: new GraphQLNonNull(InputType),\n          },\n        };\n      }\n      // If this is a table we can process it directly; but if it's a scalar\n      // setof function we must dereference '.value' from it, because this\n      // makes space for '__cursor' to exist alongside it (whereas on a table\n      // the '__cursor' can just be on the table object itself)\n      const scalarAwarePg2gql = v =>\n        isTableLike\n          ? pg2gql(v, returnType)\n          : {\n              ...v,\n              value: pg2gql(v.value, returnType),\n            };\n\n      return {\n        description: proc.description\n          ? proc.description\n          : isTableLike && proc.returnsSet\n            ? `Reads and enables pagination through a set of \\`${\n                TableType.name\n              }\\`.`\n            : null,\n        type: ReturnType,\n        args: args,\n        resolve: computed\n          ? (data, _args, _context, resolveInfo) => {\n              const safeAlias = getSafeAliasFromResolveInfo(resolveInfo);\n              const value = data[safeAlias];\n              if (returnFirstValueAsValue) {\n                if (proc.returnsSet && !forceList) {\n                  // EITHER `isMutation` is true, or `ConnectionType` does not\n                  // exist - either way, we're not returning a connection.\n                  return value.data\n                    .map(firstValue)\n                    .map(v => pg2gql(v, returnType));\n                } else if (proc.returnsSet || rawReturnType.isPgArray) {\n                  return value.map(firstValue).map(v => pg2gql(v, returnType));\n                } else {\n                  return pg2gql(value, returnType);\n                }\n              } else {\n                if (proc.returnsSet && !isMutation && !forceList) {\n                  return addStartEndCursor({\n                    ...value,\n                    data: value.data ? value.data.map(scalarAwarePg2gql) : null,\n                  });\n                } else if (proc.returnsSet || rawReturnType.isPgArray) {\n                  return value.map(v => pg2gql(v, returnType));\n                } else {\n                  return pg2gql(value, returnType);\n                }\n              }\n            }\n          : async (data, args, { pgClient }, resolveInfo) => {\n              const parsedResolveInfoFragment = parseResolveInfo(resolveInfo);\n              const functionAlias = sql.identifier(Symbol());\n              const sqlMutationQuery = makeMutationCall(\n                parsedResolveInfoFragment,\n                resolveInfo.returnType,\n                {}\n              );\n\n              let queryResultRows;\n              if (isMutation) {\n                const query = makeQuery(\n                  parsedResolveInfoFragment,\n                  resolveInfo.returnType,\n                  functionAlias,\n                  functionAlias\n                );\n                const intermediateIdentifier = sql.identifier(Symbol());\n                const isVoid = returnType.id === \"2278\";\n                const isPgClass =\n                  !returnFirstValueAsValue || returnTypeTable || false;\n                try {\n                  await pgClient.query(\"SAVEPOINT graphql_mutation\");\n                  queryResultRows = await viaTemporaryTable(\n                    pgClient,\n                    isVoid\n                      ? null\n                      : sql.identifier(\n                          returnType.namespaceName,\n                          returnType.name\n                        ),\n                    sql.query`select ${\n                      isPgClass\n                        ? sql.query`${intermediateIdentifier}.*`\n                        : sql.query`${intermediateIdentifier}.${intermediateIdentifier} as ${functionAlias}`\n                    } from ${sqlMutationQuery} ${intermediateIdentifier}`,\n                    functionAlias,\n                    query,\n                    isPgClass\n                  );\n                  await pgClient.query(\"RELEASE SAVEPOINT graphql_mutation\");\n                } catch (e) {\n                  await pgClient.query(\n                    \"ROLLBACK TO SAVEPOINT graphql_mutation\"\n                  );\n                  throw e;\n                }\n              } else {\n                const query = makeQuery(\n                  parsedResolveInfoFragment,\n                  resolveInfo.returnType,\n                  sqlMutationQuery,\n                  functionAlias\n                );\n                const { text, values } = sql.compile(query);\n                if (debugSql.enabled) debugSql(text);\n                const queryResult = await pgClient.query(text, values);\n                queryResultRows = queryResult.rows;\n              }\n              const rows = queryResultRows;\n              const [row] = rows;\n              const result = (() => {\n                if (returnFirstValueAsValue) {\n                  if (proc.returnsSet && !isMutation && !forceList) {\n                    // EITHER `isMutation` is true, or `ConnectionType` does\n                    // not exist - either way, we're not returning a\n                    // connection.\n                    return row.data\n                      .map(firstValue)\n                      .map(v => pg2gql(v, returnType));\n                  } else if (proc.returnsSet || rawReturnType.isPgArray) {\n                    return rows.map(firstValue).map(v => pg2gql(v, returnType));\n                  } else {\n                    return pg2gql(firstValue(row), returnType);\n                  }\n                } else {\n                  if (proc.returnsSet && !isMutation && !forceList) {\n                    // Connection\n                    return addStartEndCursor({\n                      ...row,\n                      data: row.data ? row.data.map(scalarAwarePg2gql) : null,\n                    });\n                  } else if (proc.returnsSet || rawReturnType.isPgArray) {\n                    return rows.map(row => pg2gql(row, returnType));\n                  } else {\n                    return pg2gql(row, returnType);\n                  }\n                }\n              })();\n              if (isMutation) {\n                return {\n                  clientMutationId: args.input.clientMutationId,\n                  data: result,\n                };\n              } else {\n                return result;\n              }\n            },\n      };\n    },\n    fieldScope\n  );\n}\n"]}