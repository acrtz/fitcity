{"version":3,"sources":["../../src/plugins/PgRowByUniqueConstraint.js"],"names":["debugSql","PgRowByUniqueConstraint","builder","hook","fields","build","context","extend","parseResolveInfo","pgGetGqlTypeByTypeId","pgGetGqlInputTypeByTypeId","gql2pg","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","graphql","GraphQLNonNull","inflection","scope","isRootQuery","fieldWithHooks","class","filter","table","namespace","reduce","memo","TableType","type","id","sqlFullTableName","identifier","name","uniqueConstraints","constraint","con","classId","attributes","attribute","attr","sort","a","b","num","forEach","keys","keyAttributeNums","map","some","key","every","_","Error","fieldName","rowByUniqueKeys","getDataFromParsedResolveInfoFragment","args","InputType","typeId","column","resolve","parent","pgClient","resolveInfo","parsedResolveInfoFragment","resolveData","query","undefined","where","fragment","getTableAlias","text","values","compile","enabled","rows","row","isPgRowByUniqueConstraintField","pgFieldIntrospection"],"mappings":"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","file":"PgRowByUniqueConstraint.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport queryFromResolveData from \"../queryFromResolveData\";\nimport debugFactory from \"debug\";\nimport omit from \"../omit\";\nconst debugSql = debugFactory(\"graphile-build-pg:sql\");\n\nexport default (async function PgRowByUniqueConstraint(builder) {\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      parseResolveInfo,\n      pgGetGqlTypeByTypeId,\n      pgGetGqlInputTypeByTypeId,\n      gql2pg,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgSql: sql,\n      graphql: { GraphQLNonNull },\n      inflection,\n    } = build;\n    const { scope: { isRootQuery }, fieldWithHooks } = context;\n    if (!isRootQuery) {\n      return fields;\n    }\n    return extend(\n      fields,\n      introspectionResultsByKind.class\n        .filter(table => !!table.namespace)\n        .filter(table => !omit(table, \"read\"))\n        .reduce((memo, table) => {\n          const TableType = pgGetGqlTypeByTypeId(table.type.id);\n          const sqlFullTableName = sql.identifier(\n            table.namespace.name,\n            table.name\n          );\n          if (TableType) {\n            const uniqueConstraints = introspectionResultsByKind.constraint\n              .filter(con => con.classId === table.id)\n              .filter(con => con.type === \"u\" || con.type === \"p\");\n            const attributes = introspectionResultsByKind.attribute\n              .filter(attr => attr.classId === table.id)\n              .sort((a, b) => a.num - b.num);\n            uniqueConstraints.forEach(constraint => {\n              if (omit(constraint, \"read\")) {\n                return;\n              }\n              const keys = constraint.keyAttributeNums.map(\n                num => attributes.filter(attr => attr.num === num)[0]\n              );\n              if (keys.some(key => omit(key, \"read\"))) {\n                return;\n              }\n              if (!keys.every(_ => _)) {\n                throw new Error(\n                  \"Consistency error: could not find an attribute!\"\n                );\n              }\n              const fieldName = inflection.rowByUniqueKeys(\n                keys,\n                table,\n                constraint\n              );\n              memo[fieldName] = fieldWithHooks(\n                fieldName,\n                ({ getDataFromParsedResolveInfoFragment }) => {\n                  return {\n                    type: TableType,\n                    args: keys.reduce((memo, key) => {\n                      const InputType = pgGetGqlInputTypeByTypeId(key.typeId);\n                      if (!InputType) {\n                        throw new Error(\n                          `Could not find input type for key '${\n                            key.name\n                          }' on type '${TableType.name}'`\n                        );\n                      }\n                      memo[inflection.column(key)] = {\n                        type: new GraphQLNonNull(InputType),\n                      };\n                      return memo;\n                    }, {}),\n                    async resolve(parent, args, { pgClient }, resolveInfo) {\n                      const parsedResolveInfoFragment = parseResolveInfo(\n                        resolveInfo\n                      );\n                      const resolveData = getDataFromParsedResolveInfoFragment(\n                        parsedResolveInfoFragment,\n                        TableType\n                      );\n                      const query = queryFromResolveData(\n                        sqlFullTableName,\n                        undefined,\n                        resolveData,\n                        {},\n                        builder => {\n                          keys.forEach(key => {\n                            builder.where(\n                              sql.fragment`${builder.getTableAlias()}.${sql.identifier(\n                                key.name\n                              )} = ${gql2pg(\n                                args[inflection.column(key)],\n                                key.type\n                              )}`\n                            );\n                          });\n                        }\n                      );\n                      const { text, values } = sql.compile(query);\n                      if (debugSql.enabled) debugSql(text);\n                      const { rows: [row] } = await pgClient.query(\n                        text,\n                        values\n                      );\n                      return row;\n                    },\n                  };\n                },\n                {\n                  isPgRowByUniqueConstraintField: true,\n                  pgFieldIntrospection: constraint,\n                }\n              );\n            });\n          }\n          return memo;\n        }, {}),\n      `Adding \"row by unique constraint\" fields to root Query type`\n    );\n  });\n}: Plugin);\n"]}