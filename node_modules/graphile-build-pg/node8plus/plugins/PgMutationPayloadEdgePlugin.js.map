{"version":3,"sources":["../../src/plugins/PgMutationPayloadEdgePlugin.js"],"names":["PgMutationPayloadEdgePlugin","builder","hook","fields","build","context","extend","getTypeByName","pgGetGqlTypeByTypeId","pgSql","sql","graphql","GraphQLList","GraphQLNonNull","pgIntrospectionResultsByKind","introspectionResultsByKind","inflection","scope","isMutationPayload","pgIntrospection","pgIntrospectionTable","fieldWithHooks","recurseDataGeneratorsForField","Self","table","kind","namespace","isSelectable","TableType","type","id","tableTypeName","name","TableOrderByType","orderByType","TableEdgeType","edge","attributes","attribute","filter","attr","classId","primaryKeyConstraint","constraint","con","primaryKeys","keyAttributeNums","map","num","canOrderBy","fieldName","edgeField","addArgDataGenerator","connectionOrderBy","orderBy","rawOrderBy","Array","isArray","pgQuery","queryBuilder","aliases","expressions","unique","forEach","item","alias","specs","itemIsUnique","orders","col","_ascending","expr","fragment","getTableAlias","identifier","push","key","length","select","join","a","literal","defaultValueEnum","getValues","find","v","description","args","defaultValue","value","resolve","data","order","some","__identifiers","Object","assign","__cursor","isPgMutationPayloadEdgeField","pgFieldIntrospection"],"mappings":"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","file":"PgMutationPayloadEdgePlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport isString from \"lodash/isString\";\nimport omit from \"../omit\";\n\nexport default (function PgMutationPayloadEdgePlugin(builder) {\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      getTypeByName,\n      pgGetGqlTypeByTypeId,\n      pgSql: sql,\n      graphql: { GraphQLList, GraphQLNonNull },\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      inflection,\n    } = build;\n    const {\n      scope: { isMutationPayload, pgIntrospection, pgIntrospectionTable },\n      fieldWithHooks,\n      recurseDataGeneratorsForField,\n      Self,\n    } = context;\n    const table = pgIntrospectionTable || pgIntrospection;\n    if (\n      !isMutationPayload ||\n      !table ||\n      table.kind !== \"class\" ||\n      !table.namespace ||\n      !table.isSelectable ||\n      (omit(table, \"all\") && omit(table, \"many\"))\n    ) {\n      return fields;\n    }\n    const TableType = pgGetGqlTypeByTypeId(table.type.id);\n    const tableTypeName = TableType.name;\n    const TableOrderByType = getTypeByName(\n      inflection.orderByType(tableTypeName)\n    );\n    const TableEdgeType = getTypeByName(inflection.edge(tableTypeName));\n    if (!TableEdgeType) {\n      return fields;\n    }\n\n    const attributes = introspectionResultsByKind.attribute.filter(\n      attr => attr.classId === table.id\n    );\n    const primaryKeyConstraint = introspectionResultsByKind.constraint\n      .filter(con => con.classId === table.id)\n      .filter(con => con.type === \"p\")[0];\n    const primaryKeys =\n      primaryKeyConstraint &&\n      primaryKeyConstraint.keyAttributeNums.map(\n        num => attributes.filter(attr => attr.num === num)[0]\n      );\n    const canOrderBy = !omit(table, \"order\");\n\n    const fieldName = inflection.edgeField(table);\n    recurseDataGeneratorsForField(fieldName);\n    return extend(\n      fields,\n      {\n        [fieldName]: fieldWithHooks(\n          fieldName,\n          ({ addArgDataGenerator }) => {\n            addArgDataGenerator(function connectionOrderBy({\n              orderBy: rawOrderBy,\n            }) {\n              const orderBy =\n                canOrderBy && rawOrderBy\n                  ? Array.isArray(rawOrderBy) ? rawOrderBy : [rawOrderBy]\n                  : null;\n              return {\n                pgQuery: queryBuilder => {\n                  if (orderBy != null) {\n                    const aliases = [];\n                    const expressions = [];\n                    let unique = false;\n                    orderBy.forEach(item => {\n                      const { alias, specs, unique: itemIsUnique } = item;\n                      unique = unique || itemIsUnique;\n                      const orders = Array.isArray(specs[0]) ? specs : [specs];\n                      orders.forEach(([col, _ascending]) => {\n                        if (!col) {\n                          return;\n                        }\n                        const expr = isString(col)\n                          ? sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                              col\n                            )}`\n                          : col;\n                        expressions.push(expr);\n                      });\n                      if (alias == null) return;\n                      aliases.push(alias);\n                    });\n                    if (!unique && primaryKeys) {\n                      // Add PKs\n                      primaryKeys.forEach(key => {\n                        expressions.push(\n                          sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                            key.name\n                          )}`\n                        );\n                      });\n                    }\n                    if (aliases.length) {\n                      queryBuilder.select(\n                        sql.fragment`json_build_array(${sql.join(\n                          aliases.map(\n                            a => sql.fragment`${sql.literal(a)}::text`\n                          ),\n                          \", \"\n                        )}, json_build_array(${sql.join(expressions, \", \")}))`,\n                        \"__order_\" + aliases.join(\"__\")\n                      );\n                    }\n                  }\n                },\n              };\n            });\n\n            const defaultValueEnum =\n              canOrderBy &&\n              (TableOrderByType.getValues().find(\n                v => v.name === \"PRIMARY_KEY_ASC\"\n              ) ||\n                TableOrderByType.getValues()[0]);\n            return {\n              description: `An edge for our \\`${tableTypeName}\\`. May be used by Relay 1.`,\n              type: TableEdgeType,\n              args: canOrderBy\n                ? {\n                    orderBy: {\n                      description: `The method to use when ordering \\`${tableTypeName}\\`.`,\n                      type: new GraphQLList(\n                        new GraphQLNonNull(TableOrderByType)\n                      ),\n                      defaultValue: defaultValueEnum && defaultValueEnum.value,\n                    },\n                  }\n                : {},\n              resolve(data, { orderBy: rawOrderBy }) {\n                const orderBy =\n                  canOrderBy && rawOrderBy\n                    ? Array.isArray(rawOrderBy) ? rawOrderBy : [rawOrderBy]\n                    : null;\n                const order =\n                  orderBy && orderBy.some(item => item.alias)\n                    ? orderBy.filter(item => item.alias)\n                    : null;\n\n                if (!order) {\n                  if (data.data.__identifiers) {\n                    return Object.assign({}, data.data, {\n                      __cursor: [\"primary_key_asc\", data.data.__identifiers],\n                    });\n                  } else {\n                    return data.data;\n                  }\n                }\n                return Object.assign({}, data.data, {\n                  __cursor:\n                    data.data[\n                      `__order_${order.map(item => item.alias).join(\"__\")}`\n                    ],\n                });\n              },\n            };\n          },\n          {\n            isPgMutationPayloadEdgeField: true,\n            pgFieldIntrospection: table,\n          }\n        ),\n      },\n      `Adding edge field to mutation payload '${Self.name}'`\n    );\n  });\n}: Plugin);\n"]}