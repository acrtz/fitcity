{"version":3,"sources":["../../src/plugins/PgJWTPlugin.js"],"names":["PgJWTPlugin","builder","pgJwtTypeIdentifier","pgJwtSecret","hook","_","build","newWithHooks","pgSql","sql","pgIntrospectionResultsByKind","introspectionResultsByKind","pgRegisterGqlTypeByTypeId","pg2GqlMapper","pgTweaksByTypeId","graphql","GraphQLScalarType","inflection","Error","namespaceName","entityName","typeName","compositeClass","class","find","table","isSelectable","isInsertable","isUpdatable","isDeletable","name","compositeType","type","filter","category","namespaceId","classId","id","attributes","attribute","attr","sort","a1","a2","num","compositeTypeName","tableType","cb","JWTType","description","serialize","value","token","reduce","memo","Object","assign","aud","audience","iss","issuer","exp","expiresIn","isPgJwtType","map","values","keys","k","every","v","unmap","fragment"],"mappings":"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","file":"PgJWTPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport { sign as signJwt } from \"jsonwebtoken\";\nimport parseIdentifier from \"../parseIdentifier\";\n\nexport default (function PgJWTPlugin(\n  builder,\n  { pgJwtTypeIdentifier, pgJwtSecret }\n) {\n  builder.hook(\"init\", (_, build) => {\n    const {\n      newWithHooks,\n      pgSql: sql,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgRegisterGqlTypeByTypeId,\n      pg2GqlMapper,\n      pgTweaksByTypeId,\n      graphql: { GraphQLScalarType },\n      inflection,\n    } = build;\n    if (!pgJwtTypeIdentifier) {\n      return _;\n    }\n    if (!pgJwtSecret) {\n      throw new Error(\"pgJwtTypeIdentifier was specified without pgJwtSecret\");\n    }\n    const { namespaceName, entityName: typeName } = parseIdentifier(\n      pgJwtTypeIdentifier\n    );\n\n    const compositeClass = introspectionResultsByKind.class.find(\n      table =>\n        !table.isSelectable &&\n        !table.isInsertable &&\n        !table.isUpdatable &&\n        !table.isDeletable &&\n        table.name === typeName &&\n        table.namespaceName === namespaceName\n    );\n    if (!compositeClass) {\n      throw new Error(\n        `Could not find JWT type '\"${namespaceName}\".\"${typeName}\"'`\n      );\n    }\n    const compositeType = introspectionResultsByKind.type.filter(\n      type =>\n        type.type === \"c\" &&\n        type.category === \"C\" &&\n        type.namespaceId === compositeClass.namespaceId &&\n        type.classId === compositeClass.id\n    )[0];\n    if (!compositeType) {\n      throw new Error(\"Could not determine the type for JWT type\");\n    }\n    if (pg2GqlMapper[compositeType.id]) {\n      throw new Error(\"JWT type has already been overridden?\");\n    }\n    const attributes = introspectionResultsByKind.attribute\n      // TODO: consider adding to pgColumnFilter?\n      .filter(attr => attr.classId === compositeClass.id)\n      .sort((a1, a2) => a1.num - a2.num);\n\n    const compositeTypeName = inflection.tableType(compositeClass);\n\n    // NOTE: we deliberately do not create an input type\n    pgRegisterGqlTypeByTypeId(compositeType.id, cb => {\n      const JWTType = newWithHooks(\n        GraphQLScalarType,\n        {\n          name: compositeTypeName,\n          description:\n            \"A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519) which securely represents claims between two parties.\",\n          serialize(value) {\n            const token = attributes.reduce((memo, attr) => {\n              memo[attr.name] = value[attr.name];\n              return memo;\n            }, {});\n            return signJwt(\n              token,\n              pgJwtSecret,\n              Object.assign(\n                {},\n                token.aud\n                  ? null\n                  : {\n                      audience: \"postgraphile\",\n                    },\n                token.iss\n                  ? null\n                  : {\n                      issuer: \"postgraphile\",\n                    },\n                token.exp\n                  ? null\n                  : {\n                      expiresIn: \"1 day\",\n                    }\n              )\n            );\n          },\n        },\n        {\n          isPgJwtType: true,\n        }\n      );\n      cb(JWTType);\n\n      pg2GqlMapper[compositeType.id] = {\n        map: value => {\n          if (!value) return null;\n          const values = Object.keys(value).map(k => value[k]);\n          if (values.every(v => v == null)) {\n            return null;\n          }\n          return value;\n        },\n        unmap: () => {\n          throw new Error(\n            \"We don't support passing a JWT token into GraphQL currently\"\n          );\n        },\n      };\n\n      pgTweaksByTypeId[compositeType.id] = fragment =>\n        sql.fragment`to_json(${fragment})`;\n    });\n    return _;\n  });\n}: Plugin);\n"]}