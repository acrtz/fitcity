{"version":3,"sources":["../src/omit.js"],"names":["omit","CREATE","READ","UPDATE","DELETE","ALL","MANY","ORDER","FILTER","EXECUTE","aliases","C","R","U","D","F","O","A","M","X","PERMISSIONS_THAT_REQUIRE_READ","parse","arrOrNot","errorPrefix","arr","Array","isArray","all","arrayNormalized","concat","map","str","perms","substr","split","p","bad","find","Error","entity","permission","tags","omitSpecRaw","includeSpecRaw","kind","name","omitSpec","includeSpec","indexOf"],"mappings":"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","file":"omit.js","sourcesContent":["// @flow\n\nimport type {\n  PgProc,\n  PgClass,\n  PgAttribute,\n  PgConstraint,\n} from \"./plugins/PgIntrospectionPlugin\";\n\n/*\n * Please only use capitals for aliases and lower case for the values.\n */\nconst CREATE = \"create\";\nconst READ = \"read\";\nconst UPDATE = \"update\";\nconst DELETE = \"delete\";\nconst ALL = \"all\";\nconst MANY = \"many\";\nconst ORDER = \"order\";\nconst FILTER = \"filter\";\nconst EXECUTE = \"execute\";\n\nconst aliases = {\n  C: CREATE,\n  R: READ,\n  U: UPDATE,\n  D: DELETE,\n  F: FILTER,\n  O: ORDER,\n  A: ALL,\n  M: MANY,\n  X: EXECUTE,\n};\n\nconst PERMISSIONS_THAT_REQUIRE_READ = [UPDATE, CREATE, DELETE, ALL, MANY];\n\nfunction parse(arrOrNot, errorPrefix = \"Error\") {\n  if (!arrOrNot) {\n    return null;\n  }\n  const arr = Array.isArray(arrOrNot) ? arrOrNot : [arrOrNot];\n  let all = false;\n  const arrayNormalized = [].concat(\n    ...arr.map(str => {\n      if (str === true || str === \"*\") {\n        all = true;\n        return [];\n      }\n      if (str[0] === \":\") {\n        const perms = str\n          .substr(1)\n          .split(\"\")\n          .map(p => aliases[p]);\n        const bad = perms.find(p => !p);\n        if (bad) {\n          throw new Error(\n            `${errorPrefix} - abbreviated parameter '${bad}' not understood`\n          );\n        }\n        return perms;\n      } else {\n        const perms = str.split(\",\");\n        // TODO: warning if not in list?\n        return perms;\n      }\n    })\n  );\n  if (all) {\n    return true;\n  }\n  return arrayNormalized;\n}\n\nexport default function omit(\n  entity: PgProc | PgClass | PgAttribute | PgConstraint,\n  permission: string\n) {\n  const tags = entity.tags;\n  const omitSpecRaw = tags.omit;\n\n  // '@include' is not being released yet because it would mean every new\n  // filter we added would become a breaking change for people using @include.\n  const includeSpecRaw = null;\n  // const includeSpecRaw = tags.include;\n\n  if (omitSpecRaw && includeSpecRaw) {\n    throw new Error(\n      `Error when processing instructions for ${entity.kind} '${\n        entity.name\n      }' - you must only specify @omit or @include, not both`\n    );\n  }\n  const omitSpec = parse(\n    omitSpecRaw,\n    `Error when processing @omit instructions for ${entity.kind} '${\n      entity.name\n    }'`\n  );\n  const includeSpec = parse(\n    includeSpecRaw,\n    `Error when processing @include instructions for ${entity.kind} '${\n      entity.name\n    }'`\n  );\n\n  if (omitSpec) {\n    if (omitSpec === true) {\n      return true;\n    }\n    if (omitSpec.indexOf(READ) >= 0) {\n      const bad = PERMISSIONS_THAT_REQUIRE_READ.find(\n        p => omitSpec.indexOf(p) === -1\n      );\n      if (bad) {\n        throw new Error(\n          `Error when processing @omit for ${entity.kind} '${\n            entity.name\n          }' - we currently don't support '${bad}' when '${READ}' is forbidden, to solve this add '${bad}' to the @omit clause or use ‘@omit‘ to omit from everything`\n        );\n      }\n    }\n    return omitSpec.indexOf(permission) >= 0;\n  } else if (includeSpec) {\n    if (includeSpec === true) {\n      throw new Error(\n        `Error when processing instructions for ${entity.kind} '${\n          entity.name\n        }' - @include should specify a list of actions`\n      );\n    }\n    if (includeSpec.indexOf(READ) === -1) {\n      const bad = PERMISSIONS_THAT_REQUIRE_READ.find(\n        p => includeSpec.indexOf(p) >= 0\n      );\n      if (bad) {\n        throw new Error(\n          `Error when processing @include for ${entity.kind} '${\n            entity.name\n          }' - we currently don't support '${bad}' when '${READ}' is forbidden`\n        );\n      }\n    }\n    return includeSpec.indexOf(permission) === -1;\n  } else {\n    return false;\n  }\n}\n"]}