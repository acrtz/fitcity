{"version":3,"sources":["../src/queryFromResolveData.js"],"names":["identity","_","undefined","from","fromAlias","resolveData","options","withBuilder","pgQuery","pgCursorPrefix","reallyRawCursorPrefix","pgCalculateTotalCount","calculateHasNextPage","calculateHasPreviousPage","usesCursor","explicitlyUsesCursor","length","rawCursorPrefix","filter","queryBuilder","fn","generateNextPrevPageSql","sqlQueryAlias","canHaveCursorInWhere","queryHasBefore","queryHasFirst","offset","invert","sqlCommon","fragment","getTableExpression","getTableAlias","buildWhereClause","literal","buildWhereBoundClause","getSelectCursor","blank","value","getPgCursorPrefix","data","cursorPrefix","map","val","withPagination","withPaginationAsFields","withCursor","selectCursor","orderBy","getOrderByExpressionsAndDirections","expr","isOrderUnique","join","setCursorComparator","cursorValue","isAfter","orderByExpressionsAndDirections","sqlCursors","Array","isArray","whereBound","sqlFilter","i","sqlExpression","ascending","comparison","Number","sqlOldFilter","null","limit","getOffset","Math","max","Error","query","build","haveFields","getSelectFieldsCount","identifier","Symbol","sqlSummaryAlias","compiledData","upper","queryHasAfter","lower","queryHasZeroLimit","getFinalLimit","first","queryHasLast","last","hasNextPage","getFinalOffset","hasPreviousPage","totalCount","sqlWith","sqlFrom","fields","push","alias"],"mappings":"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","file":"queryFromResolveData.js","sourcesContent":["// @flow\nimport QueryBuilder from \"./QueryBuilder\";\nimport sql from \"pg-sql2\";\nimport type { SQL } from \"pg-sql2\";\nimport type { DataForType } from \"graphile-build\";\nimport isSafeInteger from \"lodash/isSafeInteger\";\n\nconst identity = _ => _ !== null && _ !== undefined;\n\nexport default (\n  from: SQL,\n  fromAlias: ?SQL,\n  resolveData: DataForType,\n  options: {\n    withPagination?: boolean,\n    withPaginationAsFields?: boolean,\n    asJson?: boolean,\n    asJsonAggregate?: boolean,\n    addNullCase?: boolean,\n    onlyJsonField?: boolean,\n  },\n  withBuilder?: (builder: QueryBuilder) => void\n) => {\n  const {\n    pgQuery,\n    pgCursorPrefix: reallyRawCursorPrefix,\n    pgCalculateTotalCount,\n    calculateHasNextPage,\n    calculateHasPreviousPage,\n    usesCursor: explicitlyUsesCursor,\n  } = resolveData;\n\n  const usesCursor: boolean =\n    (explicitlyUsesCursor && explicitlyUsesCursor.length > 0) ||\n    (calculateHasNextPage && calculateHasNextPage.length > 0) ||\n    (calculateHasPreviousPage && calculateHasPreviousPage.length > 0) ||\n    false;\n  const rawCursorPrefix =\n    reallyRawCursorPrefix && reallyRawCursorPrefix.filter(identity);\n\n  const queryBuilder = new QueryBuilder();\n  queryBuilder.from(from, fromAlias ? fromAlias : undefined);\n\n  for (const fn of pgQuery || []) {\n    fn(queryBuilder, resolveData);\n  }\n  if (withBuilder) {\n    withBuilder(queryBuilder);\n  }\n\n  function generateNextPrevPageSql(\n    sqlQueryAlias,\n    canHaveCursorInWhere,\n    queryHasBefore,\n    queryHasFirst,\n    offset = 0,\n    invert = false\n  ) {\n    // if invert is true queryHasBefore means queryHasAfter; queryHasFirst means queryHasLast; etc\n    const sqlCommon = sql.fragment`\n      select 1\n      from ${queryBuilder.getTableExpression()} as ${queryBuilder.getTableAlias()}\n      where ${queryBuilder.buildWhereClause(!invert, invert, options)}\n    `;\n    if (!queryHasBefore && !queryHasFirst && (!invert || offset === 0)) {\n      // There can be no next page since there's no upper bound\n      return sql.literal(false);\n    } else if (queryHasBefore && (!invert || offset === 0)) {\n      // Simply see if there are any records after the before cursor\n      return sql.fragment`exists(\n        ${sqlCommon}\n        and not (${queryBuilder.buildWhereBoundClause(invert)})\n      )`;\n    } else if (canHaveCursorInWhere && (!invert || offset === 0)) {\n      // Query must have \"first\"\n      // Drop the limit, see if there are any records that aren't already in the list we've fetched\n      return sql.fragment`exists(\n        ${sqlCommon}\n        and (${queryBuilder.getSelectCursor()})::text not in (select __cursor::text from ${sqlQueryAlias})\n        ${offset === 0 ? sql.blank : sql.fragment`offset ${sql.value(offset)}`}\n      )`;\n    } else {\n      if (!invert) {\n        // Skip over the already known entries, are there any left?\n        return sql.fragment`exists(\n          ${sqlCommon}\n          offset (select coalesce((select count(*) from ${sqlQueryAlias}), 0) + ${sql.value(\n          offset\n        )})\n        )`;\n      } else {\n        // Things get somewhat more complex here... Let's just assume if offset > 0 there's a previous page.\n        if (offset > 0) {\n          return sql.literal(true);\n        }\n        // And here (offset === 0 && invert) so we'd have hit an earlier case; since we haven't there must be no previous page.\n        return sql.literal(false);\n      }\n    }\n  }\n  const getPgCursorPrefix = () =>\n    rawCursorPrefix && rawCursorPrefix.length > 0\n      ? rawCursorPrefix\n      : queryBuilder.data.cursorPrefix.map(val => sql.literal(val));\n  if (\n    options.withPagination ||\n    options.withPaginationAsFields ||\n    options.withCursor\n  ) {\n    // Sometimes we need a __cursor even if it's not a collection; e.g. to get the edge field on a mutation\n    if (usesCursor) {\n      queryBuilder.selectCursor(() => {\n        const orderBy = queryBuilder\n          .getOrderByExpressionsAndDirections()\n          .map(([expr]) => expr);\n        if (queryBuilder.isOrderUnique() && orderBy.length > 0) {\n          return sql.fragment`json_build_array(${sql.join(\n            [\n              ...getPgCursorPrefix(),\n              sql.fragment`json_build_array(${sql.join(orderBy, \", \")})`,\n            ],\n            \", \"\n          )})`;\n        } else {\n          return sql.fragment`json_build_array(${sql.join(\n            getPgCursorPrefix(),\n            \", \"\n          )}, (row_number() over (partition by 1)))`;\n        }\n      });\n    }\n  }\n  if (options.withPagination || options.withPaginationAsFields) {\n    queryBuilder.setCursorComparator((cursorValue, isAfter) => {\n      const orderByExpressionsAndDirections = queryBuilder.getOrderByExpressionsAndDirections();\n      if (\n        orderByExpressionsAndDirections.length > 0 &&\n        queryBuilder.isOrderUnique()\n      ) {\n        const sqlCursors = cursorValue[getPgCursorPrefix().length].map(val =>\n          sql.value(val)\n        );\n        if (!Array.isArray(sqlCursors)) {\n          queryBuilder.whereBound(sql.literal(false), isAfter);\n        }\n        let sqlFilter = sql.fragment`false`;\n        for (let i = orderByExpressionsAndDirections.length - 1; i >= 0; i--) {\n          const [sqlExpression, ascending] = orderByExpressionsAndDirections[i];\n          // If ascending and isAfter then >\n          // If ascending and isBefore then <\n          const comparison =\n            Number(ascending) ^ Number(!isAfter)\n              ? sql.fragment`>`\n              : sql.fragment`<`;\n\n          const sqlOldFilter = sqlFilter;\n          sqlFilter = sql.fragment`\n          (\n            (\n              ${sqlExpression} ${comparison} ${sqlCursors[i] || sql.null}\n            )\n          OR\n            (\n              (\n                ${sqlExpression} = ${sqlCursors[i] || sql.null}\n              AND\n                ${sqlOldFilter}\n              )\n            )\n          )\n          `;\n        }\n        queryBuilder.whereBound(sqlFilter, isAfter);\n      } else if (\n        cursorValue[0] === \"natural\" &&\n        isSafeInteger(cursorValue[1]) &&\n        cursorValue[1] >= 0\n      ) {\n        if (isAfter) {\n          queryBuilder.offset(() => cursorValue[1]);\n        } else {\n          queryBuilder.limit(() => {\n            const offset = queryBuilder.getOffset();\n            return Math.max(0, cursorValue[1] - offset - 1);\n          });\n        }\n      } else {\n        throw new Error(\"Cannot use cursors without orderBy\");\n      }\n    });\n\n    const query = queryBuilder.build(options);\n    const haveFields = queryBuilder.getSelectFieldsCount() > 0;\n    const sqlQueryAlias = sql.identifier(Symbol());\n    const sqlSummaryAlias = sql.identifier(Symbol());\n    //\n    // Tables should ALWAYS push their PK onto the order stack, if this isn't\n    // present then we're either dealing with a view or a table without a PK.\n    // Either way, we don't have anything to guarantee uniqueness so we need to\n    // fall back to limit/offset.\n    //\n    // TODO: support unique keys in PgAllRows etc\n    // TODO: add a warning for cursor-based pagination when using the fallback\n    // TODO: if it is a view maybe add a warning encouraging pgViewUniqueKey\n    const canHaveCursorInWhere =\n      queryBuilder.getOrderByExpressionsAndDirections().length > 0 &&\n      queryBuilder.isOrderUnique();\n    const queryHasBefore =\n      queryBuilder.compiledData.whereBound.upper.length > 0;\n    const queryHasAfter = queryBuilder.compiledData.whereBound.lower.length > 0;\n    const queryHasZeroLimit = queryBuilder.getFinalLimit() === 0;\n    const queryHasFirst = isSafeInteger(queryBuilder.compiledData.first);\n    const queryHasLast = isSafeInteger(queryBuilder.compiledData.last);\n    const hasNextPage = queryHasZeroLimit\n      ? sql.literal(false)\n      : generateNextPrevPageSql(\n          sqlQueryAlias,\n          canHaveCursorInWhere,\n          queryHasBefore,\n          queryHasFirst,\n          queryBuilder.getFinalOffset() || 0\n        );\n    const hasPreviousPage = queryHasZeroLimit\n      ? sql.literal(false)\n      : generateNextPrevPageSql(\n          sqlQueryAlias,\n          canHaveCursorInWhere,\n          queryHasAfter,\n          queryHasLast,\n          queryBuilder.getFinalOffset() || 0,\n          true\n        );\n\n    const totalCount = sql.fragment`(\n      select count(*)\n      from ${queryBuilder.getTableExpression()} as ${queryBuilder.getTableAlias()}\n      where ${queryBuilder.buildWhereClause(false, false, options)}\n    )`;\n    const sqlWith = haveFields\n      ? sql.fragment`with ${sqlQueryAlias} as (${query}), ${sqlSummaryAlias} as (select json_agg(to_json(${sqlQueryAlias})) as data from ${sqlQueryAlias})`\n      : sql.fragment``;\n    const sqlFrom = sql.fragment``;\n    const fields: Array<[SQL, string]> = [];\n    if (haveFields) {\n      fields.push([\n        sql.fragment`coalesce((select ${sqlSummaryAlias}.data from ${sqlSummaryAlias}), '[]'::json)`,\n        \"data\",\n      ]);\n      if (calculateHasNextPage) {\n        fields.push([hasNextPage, \"hasNextPage\"]);\n      }\n      if (calculateHasPreviousPage) {\n        fields.push([hasPreviousPage, \"hasPreviousPage\"]);\n      }\n    }\n    if (pgCalculateTotalCount) {\n      fields.push([totalCount, \"totalCount\"]);\n    }\n    if (options.withPaginationAsFields) {\n      return sql.fragment`${sqlWith} select ${sql.join(\n        fields.map(\n          ([expr, alias]) => sql.fragment`${expr} as ${sql.identifier(alias)}`\n        ),\n        \", \"\n      )} ${sqlFrom}`;\n    } else {\n      return sql.fragment`${sqlWith} select json_build_object(${sql.join(\n        fields.map(\n          ([expr, alias]) => sql.fragment`${sql.literal(alias)}::text, ${expr}`\n        ),\n        \", \"\n      )}) ${sqlFrom}`;\n    }\n  } else {\n    const query = queryBuilder.build(options);\n    return query;\n  }\n};\n"]}