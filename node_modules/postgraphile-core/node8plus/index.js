"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.watchPostGraphQLSchema = exports.createPostGraphQLSchema = exports.postGraphQLClassicIdsInflection = exports.postGraphQLInflection = exports.postGraphQLClassicIdsOverrides = exports.postGraphQLBaseOverrides = exports.watchPostGraphileSchema = exports.createPostGraphileSchema = exports.PostGraphileClassicIdsInflectionPlugin = exports.PostGraphileInflectionPlugin = exports.postGraphileClassicIdsInflection = exports.postGraphileInflection = exports.postGraphileClassicIdsOverrides = exports.postGraphileBaseOverrides = exports.inflections = undefined;

var _fs = require("fs");

var _fs2 = _interopRequireDefault(_fs);

var _graphileBuild = require("graphile-build");

var _graphileBuildPg = require("graphile-build-pg");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ensureValidPlugins = (name, arr) => {
  if (!Array.isArray(arr)) {
    throw new Error(`Option '${name}' should be an array`);
  }
  for (let i = 0, l = arr.length; i < l; i++) {
    const fn = arr[i];
    if (typeof fn !== "function") {
      throw new Error(`Option '${name}' should be an array of functions, found '${typeof fn}' at index ${i}`);
    }
  }
};


/*
 * BELOW HERE IS DEPRECATED!!
 */
exports.inflections = _graphileBuildPg.inflections;
const postGraphileBaseOverrides = exports.postGraphileBaseOverrides = {
  enumName(value) {
    return _graphileBuildPg.inflections.defaultUtils.constantCase(_graphileBuildPg.inflections.defaultInflection.enumName(value));
  }
};

const postGraphileClassicIdsOverrides = exports.postGraphileClassicIdsOverrides = {
  column(name, _table, _schema) {
    return name === "id" ? "rowId" : _graphileBuildPg.inflections.defaultUtils.camelCase(name);
  }
};

const postGraphileInflection = exports.postGraphileInflection = _graphileBuildPg.inflections.newInflector(postGraphileBaseOverrides);

const postGraphileClassicIdsInflection = exports.postGraphileClassicIdsInflection = _graphileBuildPg.inflections.newInflector(Object.assign({}, postGraphileBaseOverrides, postGraphileClassicIdsOverrides));
/*
 * ABOVE HERE IS DEPRECATED.
 */

const PostGraphileInflectionPlugin = exports.PostGraphileInflectionPlugin = function (builder) {
  builder.hook("inflection", inflection => {
    const previous = inflection.enumName;
    return {
      ...inflection,
      enumName(value) {
        return this.constantCase(previous.call(this, value));
      }
    };
  });
};

const PostGraphileClassicIdsInflectionPlugin = exports.PostGraphileClassicIdsInflectionPlugin = function (builder) {
  builder.hook("inflection", inflection => {
    const previous = inflection._columnName;
    return {
      ...inflection,
      _columnName(attr, options) {
        const previousValue = previous.call(this, attr, options);
        return options && options.skipRowId || previousValue !== "id" ? previousValue : this.camelCase("rowId");
      }
    };
  });
};

const awaitKeys = async obj => {
  const result = {};
  for (const k in obj) {
    result[k] = await obj[k];
  }
  return result;
};

const getPostGraphileBuilder = async (pgConfig, schemas, options = {}) => {
  const {
    dynamicJson,
    classicIds,
    nodeIdFieldName,
    replaceAllPlugins,
    appendPlugins = [],
    prependPlugins = [],
    skipPlugins = [],
    jwtPgTypeIdentifier,
    jwtSecret,
    disableDefaultMutations,
    graphileBuildOptions,
    graphqlBuildOptions, // DEPRECATED!
    inflector, // NO LONGER SUPPORTED!
    pgColumnFilter,
    viewUniqueKey,
    enableTags = true,
    readCache,
    writeCache,
    setWriteCacheCallback,
    legacyRelations = "deprecated", // TODO: Change to 'omit' in v5
    setofFunctionsContainNulls = true,
    legacyJsonUuid = false,
    simpleCollections = "omit"
  } = options;

  if (legacyRelations && ["only", "deprecated", "omit"].indexOf(legacyRelations) < 0) {
    throw new Error("Invalid configuration for legacy relations: " + JSON.stringify(legacyRelations));
  }
  if (simpleCollections && ["only", "both", "omit"].indexOf(simpleCollections) < 0) {
    throw new Error("Invalid configuration for simple collections: " + JSON.stringify(simpleCollections));
  }
  if (replaceAllPlugins) {
    ensureValidPlugins("replaceAllPlugins", replaceAllPlugins);
    if (prependPlugins && prependPlugins.length || appendPlugins && appendPlugins.length) {
      throw new Error("When using 'replaceAllPlugins' you must not specify 'appendPlugins'/'prependPlugins'");
    }
  }
  if (readCache && writeCache) {
    throw new Error("Use `readCache` or `writeCache` - not both.");
  }

  let persistentMemoizeWithKey = undefined; // NOT null, otherwise it won't default correctly.
  let memoizeCache = {};

  if (readCache) {
    memoizeCache = JSON.parse((await new Promise((resolve, reject) => {
      _fs2.default.readFile(readCache, "utf8", (err, data) => {
        if (err) {
          reject(err);
        } else {
          resolve(data);
        }
      });
    })));
  }
  if (readCache || writeCache) {
    persistentMemoizeWithKey = (key, fn) => {
      if (!(key in memoizeCache)) {
        if (readCache) {
          throw new Error(`Expected cache to contain key: ${key}`);
        }
        memoizeCache[key] = fn();
        if (memoizeCache[key] === undefined) {
          throw new Error(`Cannot memoize 'undefined' - use 'null' instead`);
        }
      }
      return memoizeCache[key];
    };
  }

  if (writeCache && setWriteCacheCallback) {
    setWriteCacheCallback(() => awaitKeys(memoizeCache).then(obj => new Promise((resolve, reject) => {
      _fs2.default.writeFile(writeCache, JSON.stringify(obj), err => {
        memoizeCache = {};
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    })));
  } else if (writeCache) {
    throw new Error("Cannot write cache without 'setWriteCacheCallback'");
  } else if (setWriteCacheCallback) {
    setWriteCacheCallback(() => Promise.resolve());
  }

  ensureValidPlugins("prependPlugins", prependPlugins);
  ensureValidPlugins("appendPlugins", appendPlugins);
  ensureValidPlugins("skipPlugins", skipPlugins);
  if (inflector) {
    throw new Error("Custom inflector arguments are no longer supported, please use the inflector plugin API instead");
  }
  const inflectionOverridePlugins = classicIds ? [PostGraphileInflectionPlugin, PostGraphileClassicIdsInflectionPlugin] : [PostGraphileInflectionPlugin];
  return (0, _graphileBuild.getBuilder)((replaceAllPlugins ? [...prependPlugins, ...replaceAllPlugins, ...inflectionOverridePlugins, ...appendPlugins] : [...prependPlugins, ..._graphileBuild.defaultPlugins, ..._graphileBuildPg.defaultPlugins, ...inflectionOverridePlugins, ...appendPlugins]).filter(p => skipPlugins.indexOf(p) === -1), Object.assign({
    pgConfig: pgConfig,
    pgSchemas: Array.isArray(schemas) ? schemas : [schemas],
    pgExtendedTypes: !!dynamicJson,
    pgColumnFilter: pgColumnFilter || (() => true),
    pgInflection: inflector || (classicIds ? postGraphileClassicIdsInflection : postGraphileInflection),
    nodeIdFieldName: nodeIdFieldName || (classicIds ? "id" : "nodeId"),
    pgJwtTypeIdentifier: jwtPgTypeIdentifier,
    pgJwtSecret: jwtSecret,
    pgDisableDefaultMutations: disableDefaultMutations,
    pgViewUniqueKey: viewUniqueKey,
    pgEnableTags: enableTags,
    pgLegacyRelations: legacyRelations,
    pgLegacyJsonUuid: legacyJsonUuid,
    persistentMemoizeWithKey,
    pgForbidSetofFunctionsToReturnNull: !setofFunctionsContainNulls,
    pgSimpleCollections: simpleCollections
  }, graphileBuildOptions, graphqlBuildOptions // DEPRECATED!
  ));
};

function abort(e) {
  /* eslint-disable no-console */
  console.error("Error occured whilst writing cache");
  console.error(e);
  process.exit(1);
  /* eslint-enable */
}

const createPostGraphileSchema = exports.createPostGraphileSchema = async (pgConfig, schemas, options = {}) => {
  let writeCache;
  const builder = await getPostGraphileBuilder(pgConfig, schemas, Object.assign({}, options, {
    setWriteCacheCallback(fn) {
      writeCache = fn;
    }
  }));
  const schema = builder.buildSchema();
  if (writeCache) writeCache().catch(abort);
  return schema;
};

/*
 * Unless an error occurs, `onNewSchema` is guaranteed to be called before this promise resolves
 */
const watchPostGraphileSchema = exports.watchPostGraphileSchema = async (pgConfig, schemas, options = {}, onNewSchema) => {
  if (typeof onNewSchema !== "function") {
    throw new Error("You cannot call watchPostGraphileSchema without a function to pass new schemas to");
  }
  if (options.readCache) {
    throw new Error("Using readCache in watch mode does not make sense.");
  }
  let writeCache;
  const builder = await getPostGraphileBuilder(pgConfig, schemas, Object.assign({}, options, {
    setWriteCacheCallback(fn) {
      writeCache = fn;
    }
  }));
  let released = false;
  function handleNewSchema(...args) {
    if (writeCache) writeCache().catch(abort);
    onNewSchema(...args);
  }
  await builder.watchSchema(handleNewSchema);

  return async function release() {
    if (released) return;
    released = true;
    await builder.unwatchSchema();
  };
};

// Backwards compat
const postGraphQLBaseOverrides = exports.postGraphQLBaseOverrides = postGraphileBaseOverrides;
const postGraphQLClassicIdsOverrides = exports.postGraphQLClassicIdsOverrides = postGraphileClassicIdsOverrides;
const postGraphQLInflection = exports.postGraphQLInflection = postGraphileInflection;
const postGraphQLClassicIdsInflection = exports.postGraphQLClassicIdsInflection = postGraphileClassicIdsInflection;
const createPostGraphQLSchema = exports.createPostGraphQLSchema = createPostGraphileSchema;
const watchPostGraphQLSchema = exports.watchPostGraphQLSchema = watchPostGraphileSchema;
//# sourceMappingURL=index.js.map